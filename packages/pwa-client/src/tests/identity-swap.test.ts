import { describe, it, expect, beforeEach, vi } from 'vitest';
import { bytesToHex } from '@/lib/hex';
import { generateSecretKey, getPublicKey, finalizeEvent, type EventTemplate } from 'nostr-tools';

// Mock localStorage
const localStorageMock = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => { store[key] = value; },
    clear: () => { store = {}; },
    removeItem: (key: string) => { delete store[key]; }
  };
})();

global.localStorage = localStorageMock as Storage;

// Mock window.nostr for NIP-07 testing
const nostrExtensionMock = {
  signEvent: vi.fn(),
  getPublicKey: vi.fn(),
};

(global as unknown as { window: unknown }).window = { nostr: nostrExtensionMock };

describe('Identity Migration Functionality', () => {
  let autoGeneratedSk: Uint8Array;
  let autoGeneratedPk: string;
  let realIdentitySk: Uint8Array;
  let realIdentityPk: string;
  const _groupId = 'test-group-123';

  beforeEach(() => {
    localStorage.clear();
    vi.clearAllMocks();

    // Generate auto-generated identity
    autoGeneratedSk = generateSecretKey();
    autoGeneratedPk = getPublicKey(autoGeneratedSk);

    // Generate real identity
    realIdentitySk = generateSecretKey();
    realIdentityPk = getPublicKey(realIdentitySk);

    // Store auto-generated identity
    const autoIdentity = {
      secretKey: bytesToHex(autoGeneratedSk),
      publicKey: autoGeneratedPk,
      isAutoGenerated: true,
      createdAt: Date.now()
    };
    localStorage.setItem('peek_anonymous_identity', JSON.stringify(autoIdentity));
  });

  describe('Auto-generated Identity Creation', () => {
    it('should create identity with isAutoGenerated flag', () => {
      const stored = JSON.parse(localStorage.getItem('peek_anonymous_identity') || '{}');
      expect(stored.isAutoGenerated).toBe(true);
      expect(stored.publicKey).toBe(autoGeneratedPk);
      expect(stored.createdAt).toBeDefined();
    });

    it('should not show identity button on /c/ pages', () => {
      // This would be tested in a component test
      const pathname = '/c/some-uuid';
      const shouldShowButton = !pathname.startsWith('/c/');
      expect(shouldShowButton).toBe(false);
    });
  });

  describe('Identity Migration Storage', () => {
    it('should store identity migration mapping', () => {
      // Store migration (this would normally be done by UserIdentityButton)
      const migrations = { [autoGeneratedPk]: realIdentityPk };
      localStorage.setItem('identity_migrations', JSON.stringify(migrations));

      // Verify migration is stored
      const stored = JSON.parse(localStorage.getItem('identity_migrations') || '{}');
      expect(stored[autoGeneratedPk]).toBe(realIdentityPk);
    });

    it('should handle multiple identity swaps', () => {
      const identity1 = getPublicKey(generateSecretKey());
      const identity2 = getPublicKey(generateSecretKey());
      const identity3 = getPublicKey(generateSecretKey());

      // Multiple swaps: auto -> id1 -> id2 -> id3
      const migrations = {
        [autoGeneratedPk]: identity1,
        [identity1]: identity2,
        [identity2]: identity3
      };
      localStorage.setItem('identity_migrations', JSON.stringify(migrations));

      const stored = JSON.parse(localStorage.getItem('identity_migrations') || '{}');

      // Check migration chain
      expect(stored[autoGeneratedPk]).toBe(identity1);
      expect(stored[identity1]).toBe(identity2);
      expect(stored[identity2]).toBe(identity3);
    });
  });

  describe('Message History Preservation', () => {
    it('should recognize migrated identity messages as own', () => {
      // Store migration mapping
      const migrations = { [autoGeneratedPk]: realIdentityPk };
      localStorage.setItem('identity_migrations', JSON.stringify(migrations));

      // Simulate message from old identity
      const message = {
        id: 'msg-1',
        pubkey: autoGeneratedPk,
        content: 'Hello world',
        created_at: Date.now()
      };

      // Current identity
      const currentIdentity = { publicKey: realIdentityPk };

      // Check if message is recognized as own
      const stored = JSON.parse(localStorage.getItem('identity_migrations') || '{}');
      const isOwnMessage =
        currentIdentity.publicKey === message.pubkey ||
        stored[message.pubkey] === currentIdentity.publicKey;

      expect(isOwnMessage).toBe(true);
    });

    it('should handle messages from non-migrated identities', () => {
      const otherPubkey = getPublicKey(generateSecretKey());

      // Store migration mapping (not including otherPubkey)
      const migrations = { [autoGeneratedPk]: realIdentityPk };
      localStorage.setItem('identity_migrations', JSON.stringify(migrations));

      // Message from other user
      const message = {
        id: 'msg-2',
        pubkey: otherPubkey,
        content: 'Hello from another user',
        created_at: Date.now()
      };

      // Current identity
      const currentIdentity = { publicKey: realIdentityPk };

      // Check if message is recognized as own (should be false)
      const stored = JSON.parse(localStorage.getItem('identity_migrations') || '{}');
      const isOwnMessage =
        currentIdentity.publicKey === message.pubkey ||
        stored[message.pubkey] === currentIdentity.publicKey;

      expect(isOwnMessage).toBe(false);
    });
  });

  describe('Joined Groups Tracking', () => {
    it('should require joined groups before swap', () => {
      // Clear joined groups
      localStorage.removeItem('joinedGroups');

      // Attempting swap should fail early
      const joinedGroups = JSON.parse(localStorage.getItem('joinedGroups') || '[]');
      expect(joinedGroups.length).toBe(0);
    });

    it('should track joined groups', () => {
      const joinedGroups = [
        { groupId: 'group1', name: 'Test Group 1' },
        { groupId: 'group2', name: 'Test Group 2' }
      ];
      localStorage.setItem('joinedGroups', JSON.stringify(joinedGroups));

      const stored = JSON.parse(localStorage.getItem('joinedGroups') || '[]');
      expect(stored.length).toBe(2);
      expect(stored[0].groupId).toBe('group1');
      expect(stored[1].groupId).toBe('group2');
    });
  });

  describe('Migration Event Creation', () => {
    it('should create valid migration event (kind 1776)', () => {
      // Create migration event
      const proofTemplate: EventTemplate = {
        kind: 1776,
        content: '',
        tags: [['p', autoGeneratedPk]],
        created_at: Math.floor(Date.now() / 1000)
      };
      const proofEvent = finalizeEvent(proofTemplate, realIdentitySk);

      // Create migration event signed by old identity
      const migrationTemplate: EventTemplate = {
        kind: 1776,
        content: JSON.stringify(proofEvent),
        tags: [['p', realIdentityPk]],
        created_at: Math.floor(Date.now() / 1000)
      };
      const migrationEvent = finalizeEvent(migrationTemplate, autoGeneratedSk);

      // Verify structure
      expect(migrationEvent.kind).toBe(1776);
      expect(migrationEvent.pubkey).toBe(autoGeneratedPk);
      expect(migrationEvent.tags[0][0]).toBe('p');
      expect(migrationEvent.tags[0][1]).toBe(realIdentityPk);

      // Verify proof is embedded
      const embeddedProof = JSON.parse(migrationEvent.content);
      expect(embeddedProof.kind).toBe(1776);
      expect(embeddedProof.pubkey).toBe(realIdentityPk);
      expect(embeddedProof.tags[0][1]).toBe(autoGeneratedPk);
    });

    it('should handle circular migration detection', () => {
      const identity1 = getPublicKey(generateSecretKey());
      const identity2 = getPublicKey(generateSecretKey());
      const identity3 = getPublicKey(generateSecretKey());

      // Create circular migration: 1 -> 2 -> 3 -> 1
      const migrations = {
        [identity1]: identity2,
        [identity2]: identity3,
        [identity3]: identity1
      };
      localStorage.setItem('identity_migrations', JSON.stringify(migrations));

      // Resolution should stop at circular reference
      const resolveIdentity = (pubkey: string): string => {
        const migs = JSON.parse(localStorage.getItem('identity_migrations') || '{}');
        let current = pubkey;
        const visited = new Set<string>();

        for (let i = 0; i < 10; i++) {
          if (visited.has(current)) break;
          visited.add(current);
          const next = migs[current];
          if (!next) break;
          current = next;
        }

        return current;
      };

      const resolved = resolveIdentity(identity1);
      // Should resolve to one of the identities in the circle
      expect([identity1, identity2, identity3]).toContain(resolved);
    });
  });

  describe('Identity Storage', () => {
    it('should switch from anonymous to real identity', () => {
      // Start with anonymous identity
      expect(localStorage.getItem('peek_anonymous_identity')).toBeTruthy();

      // Switch to real identity
      const realIdentity = {
        secretKey: bytesToHex(realIdentitySk),
        publicKey: realIdentityPk,
        isAutoGenerated: false
      };
      localStorage.setItem('peek_nostr_identity', JSON.stringify(realIdentity));
      localStorage.removeItem('peek_anonymous_identity');

      // Verify switch
      expect(localStorage.getItem('peek_anonymous_identity')).toBeNull();
      expect(localStorage.getItem('peek_nostr_identity')).toBeTruthy();

      const stored = JSON.parse(localStorage.getItem('peek_nostr_identity') || '{}');
      expect(stored.publicKey).toBe(realIdentityPk);
      expect(stored.isAutoGenerated).toBe(false);
    });

    it('should support NIP-07 identities without secret key', () => {
      const nip07Identity = {
        secretKey: 'NIP07_EXTENSION',
        publicKey: realIdentityPk,
        isAutoGenerated: false
      };
      localStorage.setItem('peek_nostr_identity', JSON.stringify(nip07Identity));

      const stored = JSON.parse(localStorage.getItem('peek_nostr_identity') || '{}');
      expect(stored.secretKey).toBe('NIP07_EXTENSION');
      expect(stored.publicKey).toBe(realIdentityPk);
    });
  });
});